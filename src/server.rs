//!
//!
//! A [`Server`](crate::server::Server) can be seen as a collection of requests and subscriptions.
//! Calling [`next_request`](crate::server::Server::next_request) returns a `Future` that returns
//! the next incoming request from a client.
//!
//! When a request arrives, can choose to:
//! 
//! - Answer the request immediately.
//! - Turn the request into a subscription.
//! - Ignore this request and process it later. This can only be done for requests that have an ID,
//! and not for notifications.
//!
//! ## About batches
//!
//! If a client sends [a batch](https://www.jsonrpc.org/specification#batch) of requests and/or
//! notification, the `Server` automatically splits each element of the batch. The batch is later
//! properly recomposed when the answer is sent back.
//!
//! ## Example usage
//!
//! TODO: write example
//!

use crate::raw_server::{RawServerRef, RawServerRq as _};
use crate::types::{self, from_value, to_value, JsonValue};
use fnv::FnvHashMap;
use futures::prelude::*;
use std::{collections::HashMap, io, pin::Pin};

pub use self::wrappers::http;

/*mod join;
mod run;
mod traits;*/
mod wrappers;

/// Wraps around a "raw server".
///
/// See the module-level documentation for more information.
pub struct Server<R> {
    /// Internal "raw" server.
    raw: R,

    /// Note: considering that the keys are decided by an untrusted client, it is important to use
    /// the `SipHasher` or equivalent.
    requests: HashMap<types::Id, types::MethodCall>,

    /// Keys of this hashmap are internal identifier shared between `Server` and its derivates
    /// such as `ServerRq`.
    /// The identifiers are lineraly increasing and never exposed on the wire or even outside of
    /// this API. There is therefore no risk of hash collision.
    batches: FnvHashMap<u64, Vec<RequestOrResponse>>,

    /// Next key to insert in `batches`. `batches` must never contain a key whose value is
    /// `next_batch_id`.
    next_batch_id: u64,
}

enum RequestOrResponse {

}

impl<R> Server<R> {
    /// Starts a `Server` using the given raw server internally.
    pub fn new(inner: R) -> Self {
        Server {
            raw: inner,
            // We assume that we're not going to handle more than 32 requests simultaneously,
            // which is a pretty reasonable estimate.
            requests: HashMap::with_capacity(32),
            batches: Default::default(),
            next_batch_id: 0,
        }
    }
}

impl<R> Server<R>
where
    for<'r> &'r mut R: RawServerRef<'r>
{
    /// Returns a `Future` resolving to the next request that this server generates.
    pub async fn next_request<'a>(&'a mut self) -> Result<ServerRq<'a, R>, ()> {
        // TODO: regularly call shrink_to_fit

        // This piece of code is where we analyze requests.
        loop {
            let request = self.raw.next_request().await?;
            match request.request() {
                types::Request::Single(rq) => {}       // TODO:
                types::Request::Batch(requests) => {

                }       // TODO:
            }
            unimplemented!();       // TODO:
        }

        panic!()        // TODO: 
    }

    /// Returns a request previously returned by `next_request` by its id.
    ///
    /// Note that previous notifications don't have an ID and can't be accessed with this method.
    ///
    /// Returns `None` if the request ID is invalid or if the request has already been answered in
    /// the past.
    pub fn request_by_id(&mut self, id: &types::Id) -> Option<ServerRq<R>> {
        unimplemented!()
    }

    pub fn subscriptions_by_id(&mut self, id: &String) -> Option<ServerSubscription<R>> {
        unimplemented!()
    }
}

impl<R> From<R> for Server<R> {
    fn from(inner: R) -> Self {
        Server::new(inner)
    }
}

/// Request generated by a `Server`.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerRq<'a, R> {
    server: &'a mut Server<R>,

    /// Method that is called by the request.
    method: String,

    /// Parameters of the request.
    params: types::Params,

    /// Identifier of the request if it is a method call, or `None` if it is a notification.
    id: Option<types::Id>,
}

impl<'a, R> ServerRq<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    /// Returns the id of the request.
    ///
    /// If this request object is dropped, you can retreive it again later by calling
    /// `request_by_id`. This isn't possible for notifications.
    pub fn id(&self) -> Option<types::Id> {
        unimplemented!()
    }

    /// Returns the method of this request.
    pub fn method(&self) -> &str {
        &self.method
    }

    // TODO: restore
    /*/// Returns the parameters of the request.
    pub fn params(&self) -> &JsonValue {
        &self.params
    }*/

    /// Send back a response.
    ///
    /// If this request is part of a batch:
    ///
    /// - If all requests of the batch have been responded to, then the response is actively
    ///   sent out.
    /// - Otherwise, this response is buffered.
    ///
    pub async fn respond(self, response: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }

    /// Sends back a response similar to `respond`, then returns a `ServerSubscription` object
    /// that allows you to push more data on the corresponding connection.
    // TODO: better docs
    pub async fn into_subscription(self, response: JsonValue)
        -> Result<ServerSubscription<'a, R>, io::Error>
    {
        unimplemented!();
        Ok(ServerSubscription {
            server: self.server,
        })
    }
}

/// Active subscription of a client towards a server.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerSubscription<'a, R> {
    server: &'a Server<R>,
}

impl<'a, R> ServerSubscription<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    pub fn id(&self) -> String {
        unimplemented!()
    }

    pub fn is_valid(&self) -> bool {
        true        // TODO:
    }

    /// Pushes a notification.
    pub async fn push(self, message: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }
}
