use crate::raw_server::{RawServerRef, RawServerRefRq as _};
use crate::types::{self, from_value, to_value, JsonValue};
use futures::prelude::*;
use std::{io, pin::Pin};

/*mod join;
mod run;
mod traits;*/

/// Wraps around a "raw server".
pub struct Server<R> {
    raw: R,
}

impl<R> Server<R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    /// Returns a `Future` resolving to the next request that this server generates.
    pub async fn next_request<'a>(&'a self) -> Result<ServerRq<'a, R>, ()> {
        // This piece of code is where we analyze requests.
        loop {
            let payload = self.raw.next_payload().await?;
            let request = match from_value(payload.json().clone()) {  // TODO: why the fuck is this not by ref?
                Ok(v) => v,
                Err(err) => {
                    let value = types::to_value(types::Output::invalid_request(types::Id::Null, None)).unwrap();        // TODO: no unwrap
                    payload.respond(&value).await;
                    continue;
                }
            };
        }

        panic!()
    }
}

/// Request generated by a `Server`.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerRq<'a, R> {
    server: &'a Server<R>,
    method: String,
    params: JsonValue,
}

impl<'a, R> ServerRq<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    /// Returns the method of this request.
    pub fn method(&self) -> &str {
        &self.method
    }

    /// Returns the parameters of the request.
    pub fn params(&self) -> &JsonValue {
        &self.params
    }

    /// Send back a response.
    pub async fn respond(self, response: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }

    /// Sends back a response similar to `respond`, then returns a `ServerSubscription` object
    /// that allows you to push more data on the corresponding connection.
    // TODO: better docs
    pub async fn into_subscription(self, response: JsonValue)
        -> Result<ServerSubscription<'a, R>, io::Error>
    {
        unimplemented!();
        Ok(ServerSubscription {
            server: self.server,
        })
    }
}

/// Active subscription of a client towards a server.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerSubscription<'a, R> {
    server: &'a Server<R>,
}

impl<'a, R> ServerSubscription<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    pub fn is_valid(&self) -> bool {
        true        // TODO:
    }

    /// Pushes a notification.
    pub async fn push(self, message: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }
}
