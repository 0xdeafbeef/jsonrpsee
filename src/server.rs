use crate::raw_server::{RawServerRef, RawServerRq as _};
use crate::types::{self, from_value, to_value, JsonValue};
use fnv::FnvHashMap;
use futures::prelude::*;
use std::{io, pin::Pin};

/*mod join;
mod run;
mod traits;*/

/// Wraps around a "raw server".
pub struct Server<R> {
    /// Internal "raw" server.
    raw: R,
    /// Keys of this hashmap are internal identifier shared between `Server` and its derivates
    /// such as `ServerRq`.
    batches: FnvHashMap<u64, Batch>,
    /// Next key to insert in `batches`. `batches` must never contain a key whose value is
    /// `next_batch_id`.
    next_batch_id: u64,
}

struct Batch {

}

impl<R> Server<R>
where
    for<'r> &'r mut R: RawServerRef<'r>
{
    /// Returns a `Future` resolving to the next request that this server generates.
    pub async fn next_request<'a>(&'a mut self) -> Result<ServerRq<'a, R>, ()> {
        // This piece of code is where we analyze requests.
        loop {
            let request = self.raw.next_request().await?;
            match request.request() {
                types::Request::Single(rq) => {}       // TODO:
                types::Request::Batch(requests) => {

                }       // TODO:
            }
            unimplemented!();       // TODO:
        }

        panic!()        // TODO: 
    }
}

/// Request generated by a `Server`.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerRq<'a, R> {
    server: &'a mut Server<R>,
    method: String,
    params: JsonValue,
}

impl<'a, R> ServerRq<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    /// Returns the method of this request.
    pub fn method(&self) -> &str {
        &self.method
    }

    /// Returns the parameters of the request.
    pub fn params(&self) -> &JsonValue {
        &self.params
    }

    /// Send back a response.
    ///
    /// If this request is part of a batch:
    ///
    /// - If all requests of the batch have been responded to, then the response is actively
    ///   sent out.
    /// - Otherwise, this response is buffered.
    ///
    pub async fn respond(self, response: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }

    /// Sends back a response similar to `respond`, then returns a `ServerSubscription` object
    /// that allows you to push more data on the corresponding connection.
    // TODO: better docs
    pub async fn into_subscription(self, response: JsonValue)
        -> Result<ServerSubscription<'a, R>, io::Error>
    {
        unimplemented!();
        Ok(ServerSubscription {
            server: self.server,
        })
    }
}

/// Active subscription of a client towards a server.
///
/// > **Note**: Holds a borrow of the `Server`. Therefore, must be dropped before the `Server` can
/// >           be dropped.
pub struct ServerSubscription<'a, R> {
    server: &'a Server<R>,
}

impl<'a, R> ServerSubscription<'a, R>
where
    for<'r> &'r R: RawServerRef<'r>
{
    pub fn is_valid(&self) -> bool {
        true        // TODO:
    }

    /// Pushes a notification.
    pub async fn push(self, message: JsonValue) -> Result<(), io::Error> {
        unimplemented!()
    }
}
