use crate::types;
use futures::prelude::*;
use std::{io, pin::Pin};

/// Reference to a server that can produce JSON payloads for us to answer.
///
/// This is a low-level trait implemented directly for example on HTTP or WebSockets servers.
///
/// ## Usage
///
/// A "raw server" can be seen as a collection of requests. Each request has a corresponding
/// unique identifier.
///
/// Calling `next_request` returns a `Future` that resolves when the server receives a new
/// incoming request from a connection. The `Future` updates the internal state of the server
/// to insert the new request, and returns an implementation of [`RawServerRq`] that represents
/// that newly-received request.
///
/// This [`RawServerRq`] can be dropped and retreived later by its identifier. Call `id()` on the
/// request object to grab the id of that request, then later call `request_by_id` to get back
/// the corresponding request.
///
pub trait RawServerRef<'a> {
    /// Object that can be used to send a response.
    type RawServerRq: RawServerRq<'a, RequestId = Self::RequestId>;
    /// Identifier for a request in the context of this server.
    type RequestId: PartialEq + Eq + Clone;
    /// The future that `next_request` produces.
    type NextRequest: Future<Output = Result<Self::RawServerRq, ()>> + Unpin + 'a;

    /// Returns the next request, or an error if the server has closed.
    fn next_request(self) -> Self::NextRequest;

    /// Returns the request that has the given id.
    ///
    /// Returns `None` if the `id` is invalid or represents an outdated request.
    fn request_by_id(self, id: Self::RequestId) -> Option<Self::RawServerRq>;
}

/// Request generated by a [`RawServerRef`]. Typically internally holds a reference to the server.
///
/// You can drop this object and retreive it later by grabbing its id (using the `id` method) then
/// later calling `request_by_id`.
pub trait RawServerRq<'a> {
    /// The future that `finish` produces.
    type Finish: Future<Output = Result<(), io::Error>> + Unpin + 'a;
    /// Identifier for a request in the context of this server.
    type RequestId: PartialEq + Eq + Clone;

    /// Returns a unique identifier for this request.
    fn id(&self) -> &Self::RequestId;

    /// Returns the body of the request.
    fn request(&self) -> &types::Request;

    /// Send back a response and destroys the response object.
    ///
    /// The implementation blindly sends back the response and doesn't check whether there is any
    /// correspondance with the request in terms of logic. For example, you could call `respond`
    /// in order to send back a batch of six responses despite the fact that the original request
    /// was a single notification.
    fn finish(self, response: &types::Response) -> Self::Finish;
}

/// Extension trait for `RawServerRq`.
///
/// If the request implements this trait, then it can be kept alive and you can send multiple
/// responses to it.
pub trait RawServerRqKeepAlive<'a>: RawServerRq<'a> {
    /// The future that `close` produces.
    type Close: Future<Output = Result<(), io::Error>> + Unpin + 'a;

    fn send<'s>(&'s mut self, response: &types::Response) -> Pin<Box<dyn Future<Output = Result<(), io::Error>> + 's>>;

    /// Close the request after we're done sending everything.
    fn close(self) -> Self::Close;
}
