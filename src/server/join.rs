use crate::JsonValue;
use super::{ServerRef, ServerRefRq};
use futures::prelude::*;
use std::{io, pin::Pin};

/// Joins two servers into one.
///
/// The combination of the two will produce a request whenever one of them produces a request.
//  TODO: example
pub fn join<A, B>(a: A, b: B) -> Join<A, B> {
    Join { a, b }
}

/// Joins two servers into one.
#[derive(Debug)]
pub struct Join<A, B> {
    a: A,
    b: B,
}

impl<'a, A, B> ServerRef<'a> for &'a Join<A, B>
where
    &'a A: ServerRef<'a>,
    &'a B: ServerRef<'a>,
{
    type ServerRefRq =
        JoinRq<<&'a A as ServerRef<'a>>::ServerRefRq, <&'a B as ServerRef<'a>>::ServerRefRq>;

    fn next_request(self) -> Pin<Box<dyn Future<Output = Result<Self::ServerRefRq, ()>> + 'a>> {
        Box::pin(async move {
            let outcome = {
                let a = ServerRef::next_request(&self.a);
                let b = ServerRef::next_request(&self.b);
                future::select(a, b).await
            };
            match outcome {
                future::Either::Left((a, _)) => Ok(JoinRq::Left(a?)),
                future::Either::Right((b, _)) => Ok(JoinRq::Right(b?)),
            }
        })
    }
}

/// Request generated by the `Join`.
#[derive(Debug)]
pub enum JoinRq<A, B> {
    Left(A),
    Right(B),
}

impl<A, B> ServerRefRq for JoinRq<A, B>
where
    A: ServerRefRq,
    B: ServerRefRq,
{
    fn method(&self) -> &str {
        match self {
            JoinRq::Left(a) => a.method(),
            JoinRq::Right(b) => b.method(),
        }
    }

    fn params(&self) -> &JsonValue {
        match self {
            JoinRq::Left(a) => a.params(),
            JoinRq::Right(b) => b.params(),
        }
    }

    fn respond(self, response: JsonValue) -> Pin<Box<dyn Future<Output = Result<(), io::Error>>>> {
        match self {
            JoinRq::Left(a) => a.respond(response),
            JoinRq::Right(b) => b.respond(response),
        }
    }
}
