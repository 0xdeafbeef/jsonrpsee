use futures::prelude::*;
use std::{io, pin::Pin};

/// Reference to a server that can produce JSON-RPC requests for us to answer.
pub trait ServerRef<'a> {
    /// Object that can be used to send a response.
    type ServerRefRq: ServerRefRq;

    /// Returns the next request, or an error if the server has closed.
    #[must_use]
    fn next_request(self) -> Pin<Box<dyn Future<Output = Result<Self::ServerRefRq, ()>> + 'a>>;
}

/// Request generated by a `ServerRef`. Typically internally holds a reference to the server.
pub trait ServerRefRq {
    /// Returns the method of this request.
    fn method(&self) -> &str;

    /// Send back a response.
    fn respond(self) -> Pin<Box<dyn Future<Output = Result<(), io::Error>>>>;
}

/*/// Extension trait for [`Server`] that allows pushing pub-sub messages.
pub trait ServerPubSubRef<'a>: ServerRef<'a> {
    fn push_message(&self, msg: Vec<u8>);
}*/

pub struct ServerJsonRequest<'a> {
    response_send: Box<dyn ServerRefRq + 'a>,
}

/// Abstraction over a server that can produce JSON-RPC requests for us to answer.
///
/// # How to implement
///
/// **This trait cannot be directly implemented.**
///
/// If you want to implement this trait on a type `T`, you should instead implement the `ServerRef`
/// trait on `&'a T`. The `Server` trait will then automatically be implemented on `T`.
///
pub trait Server {
    /// Returns a `Future` to the next JSON-RPC request received on this server.
    fn next_request<'a>(
        &'a self,
    ) -> Pin<Box<dyn Future<Output = Result<ServerJsonRequest<'a>, ()>> + 'a>>;
}

impl<T> Server for T
where
    for<'r> &'r T: ServerRef<'r>,
{
    fn next_request<'a>(
        &'a self,
    ) -> Pin<Box<dyn Future<Output = Result<ServerJsonRequest<'a>, ()>> + 'a>> {
        Box::pin(async move {
            let next = ServerRef::next_request(self).await?;
            Ok(ServerJsonRequest {
                response_send: Box::new(next),
            })
        })
    }
}

#[cfg(test)]
mod tests {
    use super::{Server, ServerJsonRequest};
    use futures::prelude::*;
    use std::pin::Pin;

    #[test]
    fn server_trait_prop_impl() {
        // Checks that the `Server` trait is properly implemented.
        struct Dummy;
        impl<'a> super::ServerRef<'a> for &'a Dummy {
            type ServerRefRq = DummyServerRefRq;
            fn next_request(
                self,
            ) -> Pin<Box<dyn Future<Output = Result<ServerJsonRequest<'a>, ()>> + 'a>> {
                Box::pin(future::pending())
            }
        }
        struct DummyServerRefRq;
        impl super::ServerRefRq for DummyServerRefRq {
            fn respond(self) -> Pin<Box<dyn Future<Output = Result<(), io::Error>>>> {
                unreachable!()
            }
        }

        fn req_server<T: Server>(t: &T) {}
        req_server(&Dummy);
    }
}
