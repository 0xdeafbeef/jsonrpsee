use crate::common;
use futures::prelude::*;
use std::{error, io, pin::Pin};

/// Reference to a server that can produce JSON payloads for us to answer.
///
/// This is a low-level trait implemented directly for example on HTTP or WebSockets servers.
///
/// ## Usage
///
/// A "raw server" can be seen as a collection of requests. Each request has a corresponding
/// unique identifier.
///
/// Calling `next_request` returns a `Future` that resolves when the server receives a new
/// incoming request from a connection. The `Future` updates the internal state of the server
/// to insert the new request, and returns an implementation of [`RawServerRq`] that represents
/// that newly-received request.
///
/// This [`RawServerRq`] can be dropped and retreived later by its identifier. Call `id()` on the
/// request object to grab the id of that request, then later call `request_by_id` to get back
/// the corresponding request.
///
pub trait RawServerRef<'a> {
    /// Object that can be used to send a response.
    type Request: RawServerRq<'a, RequestId = Self::RequestId>;
    /// Identifier for a request in the context of this server.
    type RequestId: PartialEq + Eq + Clone;
    /// The future that `next_request` produces.
    type NextRequest: Future<Output = Result<Self::Request, ()>> + Unpin + 'a;

    /// Returns the next request, or an error if the server has closed.
    fn next_request(self) -> Self::NextRequest;

    /// Returns the request that has the given id.
    ///
    /// Returns `None` if the `id` is invalid or represents an outdated request.
    fn request_by_id(self, id: Self::RequestId) -> Option<Self::Request>;
}

/// Request generated by a [`RawServerRef`]. Typically internally holds a reference to the server.
///
/// You can drop this object and retreive it later by grabbing its id (using the `id` method) then
/// later calling `request_by_id`.
pub trait RawServerRq<'a> {
    /// The future that `finish` produces.
    type Finish: Future<Output = ()> + Unpin + 'a;
    /// Identifier for a request in the context of this server.
    type RequestId: PartialEq + Eq + Clone;

    /// Returns a unique identifier for this request.
    fn id(&self) -> &Self::RequestId;

    /// Returns the body of the request.
    fn request(&self) -> &common::Request;

    /// Sends back a response and destroys the request object.
    ///
    /// You can pass `None` in order to destroy the request object without sending back anything.
    ///
    /// The implementation blindly sends back the response and doesn't check whether there is any
    /// correspondance with the request in terms of logic. For example, `respond` will accept
    /// sending back a batch of six responses even if the original request was a single
    /// notification.
    ///
    /// > **Note**: While this method returns a `Future` that must be driven to completion,
    /// >           implementations must be aware that the entire requests processing logic is
    /// >           blocked for as long as this `Future` is pending. As an example, you shouldn't
    /// >           use this `Future` to send back a TCP message, because if the remote is
    /// >           unresponsive and the buffers full, the `Future` would then wait for a long time.
    ///
    fn finish(self, response: Option<&common::Response>) -> Self::Finish;

    /// Sends back some data on the request and keeps the request alive.
    ///
    /// You can continue sending data on that same request later.
    ///
    /// > **Note**: This might not be supported by the underlying implementation. For example, a
    /// >           WebSockets server can support that, but not an HTTP server.
    ///
    /// > **Note**: Just like for [`finish`], the returned `Future` shouldn't take too long to
    /// >           complete.
    fn send<'s>(&'s mut self, response: &common::Response)
        -> Result<Pin<Box<dyn Future<Output = ()> + 's>>, ()>;
}
